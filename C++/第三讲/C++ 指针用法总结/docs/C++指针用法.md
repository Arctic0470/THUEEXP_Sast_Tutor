# C++指针用法

### 目录

1. 指针的基本操作

2. 部分区别与注意事项

3. 关于几类特殊指针

   - 空指针

   - 函数指针

   - 类成员指针

### 指针的基本操作

在准备开始了解指针之前，让我们先来讨论一些更基本的东西。

我们定义一个变量（如`char a`），当执行对应的代码时，一块内存空间将会被分配给该对象，我们为对象所赋的值将会被储存在这块内存空间中。在我们使用`a`这个变量时，程序需要去访问内存空间中储存的值，而为了区分不同对象的内存空间，每块内存空间都会有一个标识符，也称作该对象的地址。这个地址将会通过**地址运算符（&）**来进行访问，例如：

```c++
#include <iostream>
int main(){
    int x{ 5 };
    std::cout << x << ' ' << &x << std::endl;
    return 0;
}
```

在笔者的电脑上打印出的结果为：

``` c++
5 0000008359EFF7A4
```

地址通常是以十六进制的形式进行打印，并且省略了前缀`0x`

与获取变量地址的运算符&相对应的是**解引用运算符（*）**，其操作数是一个地址，功能是将给定地址所储存的值返回，例如`*(&x)`便是获取变量x的值。

现在，我们可以开始来聊一聊指针的相关内容了。

首先需要知道的一点是，指针是一个对象，该对象的值是另一个常规对象的地址，其定义方式也与常规对象有所区别：

```c++
int a{ 5 };//声明一个整型变量a，其值为5
int* ptr{ &a };//声明一个整数指针(指向整数变量地址的指针)，其值为整数变量a的地址
```

也就是说，通过在类型名旁添加一个*符号，我们就能够声明一个指针变量，当然，这时候\*并不是作为解引用运算符被使用。

**注意！**当在同一行中声明多个指针变量时，需要在每个指针变量前都添加一个*符号：

```c++
int* a, b, c;//声明了一个整数指针a，和两个整型变量b、c
int* x, * y, * z; //声明了三个整数指针x、y和z
```

在定义了一个指针变量后，该指针在默认情况下不会被初始化，**未初始化的指针被称作野指针**，直接使用野指针的情况通常是不被允许的：

```c++
int* x;
std::cout << x;//非法语句
std::cout << *x;//非法语句
std::cout << &x;//有效语句，x是一个指针对象，其本身也有自己的地址，地址用来存放指向对象的地址
```

一个指针变量的初始化与使用可以为：

```c++
#include <iostream>
int main(){
    int x{ 5 };
    std::cout << x << ' ';
    int* ptr{ &x };
    std::cout << *ptr;
}
```

在该例子中，指针变量`ptr`被初始化为指向变量`x`的地址，也即`ptr = &x`，所以使用解引用运算符`*`也就是获取变量`x`的值。

一个简单的事实是，指针变量的类型必须与其所指向对象的类型相匹配：

```c++
int x{ 1 };
double y{ 0.2 };
int* xptr1{ &x };//合法
int* xPtr2{ &y };//非法
double* yptr1{ &x };//非法
double* yptr2{ &y };//合法
```

指针对象在初始化后，可以通过赋值语句来改变其所指向的对象，从而获取不同对象所储存的值：

```c++
int x{ 3 };
int y{ 5 };
int* ptr{ &x };
std::cout << *ptr;//此时打印变量x的值
ptr = &y;
std::cout << *ptr;//此时打印变量y的值
```

### 部分区别与注意事项

在了解了关于指针的声明、初始化和赋值这些基本操作后，我们有必要对一些细节做出处理。

#### 指针与引用

来看一个例子：

```c++
#include <iostream>
int main(){
    int x{ 5 };
    int& y{ x };
    int* ptr{ &x };
    
    std::cout << x;
    std::cout << y; 
    std::cout << *ptr;
    
    y = 2;
    std::cout << x;
    std::cout << y;
    std::cout << *ptr;
    
    *ptr = 3;
    std::cout << x;
    std::cout << y;
    std::cout << *ptr;
    return 0;
}
```

上述程序的打印结果为：

```c++
111222333
```

在例子中我们可以发现，指针和对象的引用都能够改变对象本身的值，并且两者之间能够互通，从这个角度来看，似乎指针是通过地址运算符`&`显式获取了指向对象的地址，又通过解引用运算符`*`显式获取了所指向地址的值，而引用则只是将操作转化为隐式，两者之间没有什么差别，但其实不然，两者之间实际上有不少值得指出的区别：

- 引用在定义时必须进行初始化，而指针不用（当然，我们应该要初始化，但至少不会直接报错）
- 引用并没有重新创建一个对象，而指针则创建了一个对象
- 引用是对于一个改定对象的别名，并且指向的对象不能改变，但是指针可以
- 引用必须总是指向一个对象，而指针不用
- 通常情况下，引用是安全的，但是指针是**危险的**

关于最后两点，我们将在对于空指针的讨论中看到。

#### 地址操作符

通过`&`获取一个对象的地址（如`&a`）时，`&a`并不是将`a`的地址作为一个字符串返回，它返回的是一个包含操作数地址的指针，并且该指针的类型来自于其操作数本身，这能够解释我们在程序中不能通过一串地址来直接对一个指针进行赋值：

```c++
int a{ 5 };//定义变量a，并且&a = 0x0012FF7C
int* ptr1{ a };//合法，指针ptr1指向变量a的地址
int* ptr2{ 0x0012FF7C };//非法，尽管0x0012FF7C是一个地址，但是编译器将0x0012FF7C视作一个十六进制下的整数表示
```

#### 指针的大小

指针的大小与指针类型无关，只与编译可执行文件的体系结构（32位：4字节；64位：8字节）有关系：

```c++
#include <iostream>
int main(){//假设为64位操作系统
    char* a;
    int* b;
    long long* c;
    std::cout << sizeof(a);
    std::cout << sizeof(b);
    std::cout << sizeof(c);
    return 0;
}
```

打印语句的结果均为`8`。

### 关于几类特殊指针

#### 空指针

在之前的讨论中，我们知道指针在语法上可以不用指向任何对象，但是在使用时需要事先将其初始化，那么，在我们定义一个指针的时候，如果没有一个已知的有效对象用来作用指向目标，这种情况下，我们该如何处理呢？

事实上，我们的确不需要让指针指向一个具体的对象：

```c++
int* ptr{};
```

这个语句是合法的，此时指针`ptr`没有指向一个具体对象，而是储存了一个`null`值，在此之后，我们可以重新通过赋值语句来让`ptr`指向一个具体对象并进行使用，或者，我们还可以通过赋值语句来让一个已经指向具体对象的指针变成`null`指针，这需要用到关键字`nullptr`：

```c++
int main(){
    int a{ 5 };
    int* ptr1{ &a };//初始化指针ptr1，并让其指向对象a
    int* ptr2{ nullptr };//初始化指针ptr2，并让其指向null
    ptr2 = nullptr;//让指针ptr2重新成为null指针
}
```

**注意！**与野指针类似的是，我们应当尽量避免直接对`null`指针使用解引用运算符`*`，尽管有时编译器会为`null`指针赋予一个全为`0`的空地址，但有时直接使用也会让应用程序无法运行。

为了避免以上情况的发生，我们可以通过像布尔值`true`和`false`那样来对空指针和非空指针进行检测：

```c++
#include <iostream>
int main(){
    int x { 5 };
    int* ptr { &x };
    if (ptr) 
        std::cout << "ptr is non-null\n";
    else
        std::cout << "ptr is null\n";
    return 0;
}
```

在以上例子中，我们可以发现，指针可以隐式地转化为布尔值`true`和`false`，其中空指针被转化为`false`，而非空指针则被转化为`true`。

通过对于空指针的简单讨论，我们应该认识到，尽管指针比较灵活，但是使用指针来访问对象会给我们带来一些附加的危险，所以，在没有足够的把握时，我们**尽可能优先使用引用而不是指针**。

#### 函数指针

就像指向普通对象的指针那样，在**C++**中，我们还可以声明指向函数的指针：

```c++
#include <iostream>
void fun(int a){
    std::cout << "Value of a is " << a;
}
int main(){
    void (*fun_ptr)(int) = &fun;
    (*fun_ptr)(10);
    return 0;
}
```

程序的运行结果为：

```c++
Value of a is 10
```

但是，可以发现一个有趣的事实是，`fun`的函数指针`fun_ptr`在声明的时候添加了一个额外的括号，如果我们去掉括号（也就是`void *fun_ptr(int)`），这会发生什么呢：

```c++
#include <iostream>
void fun(int a){
    std::cout << "Value of a is " << a;
}
int main(){
    void *fun_ptr(int) = &fun;
    (*fun_ptr)(10);
    return 0;
}xxxxxxxxxx #include <iostream>void fun(int a){    std::cout << "Value of a is " << a;}int main(){    void (*fun_ptr)(int) = &fun;    (*fun_ptr)(10);    return 0;}void *fun_ptr(int) = &fun;
```

在我们将上述程序中的对应语句更换后，我们会沮丧地发现这个程序将无法正常执行，原因就在于**C++**中运算符的优先级在这个语句中依旧生效：

```c++
void *fun_ptr(int);
```

在上述语句中，运算符()将优先于运算符*，所以这个语句实际意味着我们声明了一个具有一个int类型参数和void\*返回值的函数`fun_ptr`。为避免这个烦恼，我们需要将运算符`*`与`fun_ptr`绑定，因此在原本正确的程序中，我们才会看到那个括号的出现。

> 在这里，我们看到了`void*`，这是一个`void`类型的指针，这种指针可以被任意数据类型的指针赋值，但是不能获取对象的值，我们可以通过以下的例子简单地理解：
>
> ```c++
>#include <iostream>
> int main(){
>  int a{ 5 };
>  double b{ 0.6 };
>    
>     int* ptr1{ &a };
>      double* ptr2{ &b };
>     void* ptr3;
>    
>     ptr3 = ptr1;//合法
>      std::cout << *ptr3 << std::endl;//非法
>     ptr3 = ptr2;//合法
>     std::cout << *ptr2 << std::endl;//非法
>    
>     return 0;
>     }
>    ```
> 另外，当一个函数的参数或者返回值中有`void*`类型的数据时，如果数据的类型无法确定，那么我们就可以使用`void`类型来代替。

除了上述基本应用外，函数指针还有一些其他的使用方法。比如，我们可以通过函数名来直接获取函数的地址，以最开始的程序为例：

```c++
#include <iostream>
void fun(int a){
    std::cout << "Value of a is " << a;
}
int main(){
    void (*fun_ptr)(int) = fun;
    fun_ptr(10);
    return 0;
}
```

注意到，上述程序与最开始那个程序的区别有两点：1.我们删除了`void (*fun_ptr)(int) = &fun;`语句中`fun`前面的地址运算符`&`；2.`(*fun_ptr)(10);`语句中我们同样删去了解引用运算符`*`更改了函数调用，这样程序依然有效。

此外，我们还可以创建函数指针数组，并让用户来作出决策决定指针执行的具体函数，或者将函数指针作为一个具体函数的参数进行传递，这些应用的举例我们都会在附加的`cpp`文件中给出。

#### 类成员指针

类成员指针主要分为**数据成员指针**和**成员函数指针**两种，使用方法与普通指针类似，但需要使用类限定符，但需要注意的两点是：1.为成员函数指针赋值时，需要显示使用&运算符，不能直接将“类名::成员函数名”赋给成员函数指针（即通过函数名直接获取函数地址）；2.使用数据成员指针时，被访问的成员往往是类的公有成员，如果是类的私有成员，容易出错。
