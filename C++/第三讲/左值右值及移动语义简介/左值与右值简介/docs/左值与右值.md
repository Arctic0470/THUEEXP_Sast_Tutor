# 第三讲：左值与右值

## 1. 值类别

每一个C++表达式（带有其操作数的运算符、文本、变量名称等）都具有两个独立属性的特征：`类型`和`值类别`。
每个表达式都有一些非引用类型，并且每个表达式正好属于三个主要值类别之一：`prvalue`、`xvalue` 和 `lvalue`。

- glvalue（"广义"左值）是一个表达式，其计算决定了对象或函数的恒等式;
- prvalue（"pure"rvalue）是其计算的表达式
  - 计算内置运算符的操作数的值（此类 prvalue 没有结果对象）
  - 初始化对象（这样的 prvalue 被称为具有结果对象）。
- xvalue（"eXpiring"值）是一个 glvalue，表示其资源可以重用的对象;
- 左值（历史上称为左值，因为左值可能出现在赋值表达式的左侧）是不是 x 值的 glvalue;
- 右值（历史上称为右值，因为右值可能出现在赋值表达式的右侧）是一个 prvalue 或 xvalue。


## 2. 左值与右值的定义

**左值**($lvalue$)与**右值**($rvalue$)，顾名思义，就是在等号左边与等号右边的值。但这只是形象上的理解，从本质上来看，左值有以下特点：

  - 其内存**既可读取也可写入**
  
  - 大部分的**变量**都是左值
  
    ```c++
    int *p, i; //  *p and i are lvalues
    ```
  
  - 函数返回值若为引用形式，则返回值为左值

而右值则有以下特点：

  - 其内存**只可读**, 包括**常量**($e.g.$ 10) 和**临时对象**

    ```c++
    int *p, i; //&p and i++ are rvalues
    int f() {...} //f() is rvalue
    ```

一个关于自增运算符奇怪的点是，`++i`是左值，而`i++`是右值。所以`(--a)--`能过能过编译而`--(a--)`不能过编译（但并不重要）

## 3. 常见的左值与右值

以下表达式是左值表达式：

- `变量`、`函数`、`模板参数对象（自 C++20 起）`或 `数据成员的名称`，无论其类型如何，例如`std::cin`或`std::endl`。即使变量的类型是右值引用，由其名称组成的表达式也是左值表达式;
- 函数调用或重载运算符表达式，其返回类型为左值引用，例如`std::getline`（std::cin， str）,`std::cout << 1`,`str1 = str2`或`++it`;
- `a = b`, `a += b`, `a %= b`，以及所有其他内置赋值和复合赋值表达式;
- `++a`和`--a`，内置的预增量和预递减表达式;
- `*p`，内置间接寻址表达式;
- a[n]和p[n]、内置下标表达式，其中一个操作数位于a[n]是数组左值 （自 `C++11` 起）;
- 上午，对象表达式的成员，除非其中是成员枚举器或非静态成员函数，或者其中是右值并且是对象类型的非静态数据成员;
- `p->m`，指针表达式的内置成员，除非是成员枚举器或非静态成员函数;
- `a.*mp`，指向对象表达式成员的指针，其中是左值并且是指向数据成员的指针;
- `p->*mp`，是指向指针表达式成员的内置指针，其中是指向数据成员的指针;
- a， b，内置逗号表达式，其中是左值;
- `a ? b : c`，确定和的三元条件表达式（例如，当两者都是相同类型的左值时，但有关详细信息，请参阅定义）;
- 字符串字面量，例如`"hello world!"`;
- 转换为左值引用类型的表达式，例如`static_cast<int&>（x）`;


## 4. 右值引用（&&）

在`c++11`之前，引用仅限于左值引用，即只能对左值做引用。左值引用也就是我们课上都学过的那种引用方式。  
以孙甲松老师的课件为例：

```c++
void swap(int*& a,int*& b) //利用引用来进行交换
{
    int *temp;
    temp = a;
    a = b;
    b = temp
}
```

而在`C++11`中，**右值引用**（&&）被首次提出，右值引用的主要作用是保证了在销毁临时变量之前对它们的值的**安全访问**

关于左右值引用的例子可参考如下样例：
```c++
int lval {2}; // lval is an lvalue
int f() {...} //f() is rvalue
int&& ref_rval {5}; // OK: binds to an rvalue 5
int&& ref_rval2 {lval}; // Error: rvalue ref cannot bind to lvalue
int&& ref_rval3 {lval+5}; // OK: binds to an rvalue
int&& ref_rval4 {f()}; // OK: binds to an rvalue
```

右值引用常用作函数参数。当希望对左值和右值参数具有不同的行为时，这对于函数重载最有用。
```c++
void fun(const int& lref) // l-value arguments will select this function
{
	std::cout << "l-value reference to const\n";
}

void fun(int &&rref) // r-value arguments will select this function
{
	std::cout << "r-value reference\n";
}

int main()
{
	int x{ 5 };
	fun(x); // l-value argument calls l-value version of function
	fun(5); // r-value argument calls r-value version of function

	return 0;
}
```
以上程序的输出结果为：  
l-value reference to const  
r-value reference