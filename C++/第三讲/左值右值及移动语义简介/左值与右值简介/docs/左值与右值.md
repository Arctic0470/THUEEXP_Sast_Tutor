## 第三讲：左值右值与移动语义

### 一、左值与右值

#### 1、左值与右值的定义

**左值**($lvalue$)与**右值**($rvalue$)，顾名思义，就是在等号左边与等号右边的值。但这只是形象上的理解，从本质上来看，左值有以下特点：

  - 其内存**既可读取也可写入**
  
  - 大部分的**变量**都是左值
  
    ```c++
    int *p, i; //  *p and i are lvalues
    ```
  
  - 函数返回值若为引用形式，则返回值为左值

而右值则有以下特点：

  - 其内存**只可读**, 包括**常量**($e.g.$ 10, “Hello World”) 和**临时对象**

    ```c++
    int *p, i; //&p and i++ are rvalues
    int f() {...} //f() is rvalue
    ```

一个关于自增运算符奇怪的点是，`++i`是左值，而`i++`是右值。所以`(--a)--`能过能过编译而`--(a--)`不能过编译（但并不重要）


#### 2、右值引用（&&）

在`c++11`之前，引用仅限于左值引用，即只能对左值做引用。左值引用也就是我们课上都学过的那种引用方式。  
以孙甲松老师的课件为例：

```c++
void swap(int*& a,int*& b) //利用引用来进行交换
{
    int *temp;
    temp = a;
    a = b;
    b = temp
}
```

而在`C++11`中，**右值引用**（&&）被首次提出，右值引用的主要作用是保证了在销毁临时变量之前对它们的值的**安全访问**

关于左右值引用的例子可参考如下样例：
```c++
int lval {2}; // lval is an lvalue
int f() {...} //f() is rvalue
int&& ref_rval {5}; // OK: binds to an rvalue 5
int&& ref_rval2 {lval}; // Error: rvalue ref cannot bind to lvalue
int&& ref_rval3 {lval+5}; // OK: binds to an rvalue
int&& ref_rval4 {f()}; // OK: binds to an rvalue
```

右值引用常用作函数参数。当您希望对左值和右值参数具有不同的行为时，这对于函数重载最有用。
```c++
void fun(const int &lref) // l-value arguments will select this function
{
	std::cout << "l-value reference to const\n";
}

void fun(int &&rref) // r-value arguments will select this function
{
	std::cout << "r-value reference\n";
}

int main()
{
	int x{ 5 };
	fun(x); // l-value argument calls l-value version of function
	fun(5); // r-value argument calls r-value version of function

	return 0;
}
```
以上程序的输出结果为：  
l-value reference to const  
r-value reference