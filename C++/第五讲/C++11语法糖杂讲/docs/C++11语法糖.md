# 第五讲：C++ 11 语法糖杂讲

## 5.1 `constexpr` & 常量表达式

> 我们在之前的编程学习以及在 **const的基本用法** 的介绍中，已经对 C++ 中的**常量表达式**有了初步的认识。在本节的学习中，我们会针对**常量表达式**这一重要概念继续深入，并介绍 C++ 11 新引入的 `constexpr` 机制。

那么首先，什么是常量表达式呢？

> **常量表达式**  是指  **值不会改变**  并且  **在编译过程就能得到计算结果**  的表达式。



根据上述的定义，显然我们可以知道：

- 字面值属于常量表达式；
- 用常量表达式初始化的 `const` 对象也是常量表达式；

- 一个对象是不是常量表达式，由它的**数据类型**和**初始值**共同决定。



接下来我们为大家准备了一些实例，供大家学习参考。

```c++
const int max_files = 20;			// max_files是常量表达式
const int limit = max_files + 1;	// limit是常量表达式
int staff_size = 27;				// staff_size不是常量表达式
const int sz = get_size();			// sz不是常量表达式
```

- 尽管`staff_size`的初始值是字面常量，但由于其**数据类型**只是普通的`int`而不是`const int`，所以它并不是常量表达式；
- 尽管`sz`本身是一个常量，但是它的**具体值**需要在**运行时**才能获取到，所以它也不是常量表达式。



在对常量表达式这一概念有了更为深入的认知之后，我们继续介绍关于 `constexpr` 变量的相关知识。

> 在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。

基于上述情形，C++ 11 新标准规定，允许将变量声明为 **constexpr** 类型，以便于编译器验证变量的值是否属于常量表达式。声明为 `constexpr` 的变量一定是一个常量，且必须用常量表达式初始化。

```c++
constexpr int mf = 20;			// 20是常量表达式
constexpr int limit = mf + 1;	// mf + 1是常量表达式
constexpr int sz = size();		// 只有当size()是一个constexpr函数时才是正确语句
```



我们已经知道，常量表达式的值需要在**编译**时就进行计算，因此我们必须对声明 `constexpr` 时用到的类型进行限制（因为并不是每一种类型都能在编译时得到结果）。能够被声明的类型一般比较简单，值也显而易见、容易得到，它们被称为“**字面值类型**”。

> 到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。
>
> 自定义类、IO 库、string 类型则不属于字面值类型。



值得一提的是，尽管指针和引用属于字面值类型，它们的初始值却受到**严格限制**。一个 **constexpr** 指针的初始值必须是 **nullptr** 或 **0**，或者是**存储于某个固定地址的对象**。

> **函数体内**定义的变量一般来说并非存储于固定地址，因此不能声明为 constexpr 指针所指的变量；
>
> 相反地，定义于**所有函数体外**的对象地址固定不变，可以用于初始化 constexpr 指针。



此外，在 constexpr 声明中如果定义了一个指针，限定符 constexpr **仅对指针有效**，而和指针所指的对象无关。

```c++
const int *p = nullptr;			// p是一个指向整型常量的指针
constexpr int *q = nullptr;		// q是一个指向整数的常量指针
```



同样与其他常量指针类似的是，constexpr 指针不一定指向常量。

```c++
constexpr int *np = nullptr;	// np是一个指向整数的常量指针，值为空
int j = 0;						
constexpr i = 42;				// i的类型是整形常量
// i和j都必须定义于函数体之外
constexpr const int *p = &i;	// p是常量指针，指向整型常量i
constexpr int *p1 = &j;			// p1是常量指针，指向整数j
```



## 5.2 `auto` 类型指示符

编程时，我们需要把表达式的值赋给变量，这就要求在声明变量的时候知道表达式的类型。然而在某些情况下，我们可能很难知道甚至不可能知道某些表达式的类型。C++ 11 引入的 `auto` 类型说明符就可以让**编译器代替我们**分析表达式所属的类型。

> 和原先那些只对应一种特定类型的说明符（double、float）不同，auto 会让编译器通过**初始值**来判断变量的类型。

- auto 定义的变量必须有初始值
- 使用 auto 也能在一条语句中声明多个变量
  - 因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的基本数据类型应该相同



> 在实际运用中，编译器推断得到的数据类型可能与初始值**不相同**，编译器会适当**改变结果类型**使之更符合**初始化规则**。

- 例 1 ：

```c++
int i = 0, &r = i;
auto a = r;			
// a是一个整数（r是i的别名，而i是一个整数）
// 在本例中，编译器遵循“使用引用本质上是使用引用的对象”原则
// 使用引用对变量进行初始化时，初始值应该是被引用的对象的值
// 因而a的类型被推断为整型而不是一个引用
```

- 例 2 ：

```c++
const int ci = i, &cr = ci;
auto b = ci;				
// b是一个整数（ci的顶层const特性被忽略）
auto c = cr;				
// c是一个整数（cr是ci的别名，ci的顶层const特性被忽略）
auto d = &i;				
// d是一个整型指针（整数的地址就是指向整数的指针）
auto e = &ci;				
// e是一个指向整型常量的指针（对常量对象取地址是底层const）
const auto f = ci;	
// ci的推演类型是int，这种声明方式下f就可以保留const

// 本例体现的是auto忽略顶层const而保留底层const的特性
```

- 例 3 ：

```c++
auto &g = ci;
// g是一个整型常量引用，绑定到ci
// auto &h = 42;
// 这种写法错误，不能为非常量引用绑定字面值
const auto &j = 42;
// 正确，可以为常量引用绑定字面值

// 当引用的类型被设置为auto时，原先的初始化规则仍然适用
// 设置一个类型为auto的引用时，初始值中的顶层const属性仍然保留
```



## 5.3 范围 `for` 语句

`for`循环语句作为 C++ 中十分多见的语法运用，想必大家都对此比较熟悉。在 C++ 11 的新标准中，引入了一种更为简单的`for`语句，这种语句可以遍历**容器或其他序列**的所有元素。

范围`for`语句的语法形式如下：

```c++
for (declaration : expression)
    statement
```

- expression 表示的必须是一个**序列**；
- declaration 定义一个**变量**，序列中的每一个元素都应该**能被转换成**该变量的类型；
  - 确保类型相容最简单的办法是使用`auto`类型说明符
- 每次迭代都会重新定义循环控制变量，并将其**初始化**为序列中的下一个值，之后执行 statement；
  - statement 可以是一条单独的语句，也可以是一个块。



接下来我们会以 C++ 的`vector`为例来展示范围`for`语句的使用方法。

```c++
vector<int> v = {0,1,2,3,4,5,6,7,8,9};
// 需要对元素执行写操作时，范围变量需要设置为引用类型
for (auto &r : v)		
    r *= 2;
```



## 5.4 列表初始化

C++ 语言定义了初始化的很多种形式。例如要想定义一个名为`units_sold`的`int`变量并将其初始化为 0，以下的 4 条语句都可以做到这一点：

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

> 作为 C++ 11 新标准的一部分，用`{}`来初始化变量得到了全面应用。
>
> 这种初始化的方式被称为列表初始化。

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在**丢失信息**的风险，则编译器将报错。

```c++
long double ld = 3.1415926536;
int a{ld}, b = {ld};			
// 报错：转换未执行，因为存在丢失信息的风险
int c(ld), d = ld;				
// 正确转换：自动丢失部分值
```

此外，列表初始化也可用于初始化`vector`对象。此时，用`{}`括起来的 0 个或多个元素将会被赋值给 vector 对象。

```c++
vector<string> articles = {"a", "an", "the"};
// 上述vector对象中包含列表内的3个元素
```



## 备注

本部分教程主要为大家介绍了一部分我们日常编程过程中经常能够用到的 C++ 11 的新标准和新用法，希望能为大家日后的编程学习提供一定的帮助和参考。
