# const

### 目录

1.为什么要使用const？（为什么不用别的？）

2.const的基本用法

3.const在多文件中的使用

### 1.为什么要使用const？（为什么不用别的？）

写代码时，我们需要将**数据(*data*)**存放在**变量(*variables*)**中，通过对变量进行各种运算和操作，实现功能或解决问题。然而，随着变量的不断增多和发量的不断减少，我们有时会发现：所有数据都可以存放在变量中，但单从字面上看，有些数据比其他数据更像**变**量。

为什么这么说呢？进行某些数学计算时，我们需要用到圆周率Pi；下五子棋时，我们需要知道棋盘的大小N*N。在一段程序运行的过程中，圆周率Pi或棋盘边长N往往不会发生改变（否则，我们需要操心的恐怕是一些超出这段程序的东西，比如数学大厦是不是摇摇欲坠或者某选手是不是在作弊）。但是，如果我们在声明这些变量时仅仅使用普通的double或int类型，我们便（1）很难保证我们的代码不会在某个地方稀里糊涂地修改了这些变量，尤其是当我们同时使用n,m,i,j,k,l,p,q……以及它们的大写作为变量名的时候。同时，（2）把一堆压根不会改变的数字专门用一堆变量来存放，对总体的程序而言也是不必要的开销。为了解决这些问题，我们需要使用一些新的手段。

“简单简单！这有什么难的？”小鱼儿看也不看，在程序的开头加了几行代码，它看起来好像是：

```c++
#define Pi 3.1415927
#define N 15
#define 秋季学期假期天数 0
//...
```

你也是这么想的吗？的确，我们之前学习过**宏(*macro*)**的概念和用法，也曾经在试卷上见过它，知道它会让预处理器在预处理阶段（也就是编译之前的阶段）将程序中的一些字段替换为另一些字段。但是，且不提宏命令在程序中多么容易导致错误——这个理由或许已经很充分了——还有更多原因让我们在面对那些**较为复杂的问题**时不去使用它。

1.因为它发挥作用的途径是替换文本，宏命令中的“变量”不是真正的变量，在debug时很难确定它的值。

2.宏可能在代码的其他部分引起冲突，尤其当引入的头文件个数多且宏命名不规范时。

“够了够了！我直接敲数字，总不会出错了吧？”小鱼儿不服气。

对于**简单**的程序，敲数字当然没有问题。但是当程序规模变大，尤其是这些数字需要调整时，这样做就会带来很多困难。设想新人程序员小E在上班第一天就被叫去修改这样的代码：

```c++
total_num = 5 * 2; //5是行数，2是列数
set_rows(5);
set_cols(2);
get_content(total_num);
show(screen);
funcxxx(2);
```

小E耐着性子一个个更换这些数字时，突然犯了难：这个奇怪函数funcxxx(2)里的数字要不要改？这个2是啥？？？此刻，小E只想打电话给那个被优化了的前辈，请他在送外卖之余为自己好好解释一下代码里的这些数各自究竟都是些什么意思。然后，小E要给这些数字**起好名字，写好注释**~~，让自己的后辈以后能更好地接手自己的工作~~。

“行吧行吧！其实我还可以用枚举类型enum……”小鱼儿好像还有话要说。

确实，还有其他方式来表示我们所说的“常量”，但现在是时候展示一个更加常见和广泛的用法了：**const**。

### 2.const的基本用法

#### （1）常变量

const在代码中的作用类似于形容词或副词在句子中的作用，比方说，int a是整型变量，const int a则是**常**整型变量（它也可以写作int const a，但我们不会这样写），const变量在声明之后不允许被改变，因此，我们必须在**声明的同时定义**它（给它赋值）。如果直接使用数字或表达式定义，在编译阶段就可以确定它的值，称为**静态绑定/编译时绑定**，如果只有运行过程中才能确定，则称为**动态绑定/运行时绑定**，静态绑定和动态绑定相比消耗的资源更少，但没那么灵活。

```c++
const int a = 2022;
const int b {2022}; //另一种写法
int c;
cin >> c; //键盘中输入2022，回车
const int d {c}; //不直接用数字定义const变量的方法，称为运行时绑定/动态绑定
```

在C++中，静态绑定的常变量还可以用来确定数组大小：

```c++
const int n = 100;
char text[n]; //不会报错！
```

#### （2）常·函数参数

当函数参数为指针或引用时，我们可以通过用const修饰参数来保护参数（为什么不考虑直接传递参数值的情况？请你思考），这样做可以使得指针或引用所指向的内存在函数体内无法修改，就像这样：

```c++
int max(const int* a,const int* b) {
  //...
  *a = 111; //报错！不允许修改*a的值
}
```

为指针添加const修饰时，const的位置决定了它的含义，理解它的关键在于看const后面紧跟的是什么，如下：

```c++
const int* a; //const修饰的是int，所以a指向的内存空间中的数据不允许修改。
int* const b; //const修饰的是a，所以a指向的地址不允许修改。
*a = *b; //报错！
b = a; //报错！
```

#### （3）常 in class

学习了类的知识后，我们知道const也可以用来修饰对象，得到**常对象**。与前面类似，常对象自身的内容不能改变。请你阅读以下代码：

```c++
#include<iostream>
using namespace std;
class rectangle { //定义一个矩形类
 public:
  rectangle(double l, double w) : length(l), width(w) {} //构造函数
  double length; //长
  double width; //宽

  double get_area() { return length * width; } //求矩形的面积
  bool operator < (const rectangle& r) { //比较两个矩形面积的大小
	return get_area() < r.get_area();
  }
};
int main() {
  rectangle a(2, 5), b(3, 4); //构造两个矩形
  if (a < b) cout << "矩形a的面积小于b" << endl;
  return 0;
}
```

在这段代码中，我们构造了rectangle类，并重载了它的小于号运算符<。其中虽然没有出现常对象，但出现了**对象的常引用**，在向函数传递参数时使用常引用，在函数体内这个引用就被理解为常对象，其内部数据就不会被更改。但是，如果我们把这段代码复制进编译器中，编译器会报错。**仔细看看，你能发现问题在哪吗？**

问题在于：在重载小于号时，我们调用了常引用r的get_area()函数。由于成员函数有可能修改对象内的数据，C++不允许常对象调用普通的成员函数，为此，我们需要使用的是**常成员函数**。因为get_area()函数确实没有修改成员，在本例中我们只需作如下修改就可消除bug：

```c++
double get_area() { return length * width; } //普通成员函数，需要被替换
double get_area() const { return length * width; } //常成员函数，可以被常对象调用，注意const的位置
```

常成员函数不能修改对象内的任何数据，不仅可以被常对象调用，也可以被普通对象调用，是不是很方便呢？有人说，代码出bug时不妨往里面加几个const，这话的确有几分道理呢。

### 3.const在多文件中的使用

当我们面临较大项目的编程时，可能会遇到这样的情况：有些常数在各个地方都要用，但是如果在每个文件里都定义一遍就太浪费了，要是它们定义时的精度不一样，还可能造成更大的问题。对此，**方法一**是利用我们在**上一讲**学过的有关**命名空间(*namespace*)**的知识，把所有常数放在同一个头文件**constants.h**里，如下（constexpr的用法我们会在稍后接触，现在只需把它理解为const）：

```c++
#ifndef CONSTANTS_H
#define CONSTANTS_H
namespace constants
{
  constexpr double pi { 3.1415927 };
  constexpr double avogadro { 6.0221413e23 };
  // ... 其他常数
}
#endif
```

之后，在其他文件中，可以通过“命名空间”+“::”使用这些常数，比如在main.cpp中：

```c++
#include "constants.h" // 把含常数的头文件加入这个文件
#include <iostream>
int main()
{
  std::cout << "Enter a radius: ";
  int radius{};
  std::cin >> radius;
  std::cout << "The circumference is: " << 2.0 * radius * constants::pi << '\n';
  return 0;
}
```

如果这样做，一个好处是编译器在编译时往往会直接对这些常量进行优化（用数字直接代替它）。但是，因为使用#include会导致每个文件中都有一个constants.h（使用#ifndef等命令只能保证它在每个文件**内部**只出现一次），这种方法仍然有其不足：

1.修改一个常量值（比如调整某个参数）会要求重新编译每个包含constants.h的文件，如果项目很大，这将需要很长的时间。

2.如果常量的个数太多使得编译器无法把它们优化掉，这些“变量”会消耗许多内存。

为了避免这些问题，我们可以采取**方法二**，同样利用**上一讲**中的知识，把这些常量变成**外部变量(*external variables*)**。在方法二中，我们在**constants.cpp**而不是constants.h中实例化（赋值）：

```c++
#include "constants.h"
namespace constants
{
  extern const double pi { 3.1415927 };
  extern const double avogadro { 6.0221413e23 };
  // ... 其他常数
}
```

而在**constants.h**中，我们只是简单地声明了这些常量（这种声明被称为**前向声明(*forward declaraion*)**）：

```c++
#ifndef CONSTANTS_H
#define CONSTANTS_H
namespace constants
{
    extern const double pi;
    extern const double avogadro;
    // ... 其他常数（只有声明）
}
#endif
```

（注意，这里使用的是const而不是constexpr，在学习相关知识后，你能说出为什么这里不能使用constexpr吗？）

而其他文件中的代码保持不变：

```c++
#include "constants.h" // 把含常数的头文件加入这个文件
#include <iostream>
int main()
{
  std::cout << "Enter a radius: ";
  int radius{};
  std::cin >> radius;
  std::cout << "The circumference is: " << 2.0 * radius * constants::pi << '\n';
  return 0;
}
```

在这种方法下，每个包含constants.h的文件内实际上并不包含常量们实际的取值。因此，修改常量值时只需要重新编译constants.cpp一个文件。但是，这种做法同样有缺陷：因为除了constants.cpp之外的文件在编译时只能看到constants.h中的前向声明，所以这些常量都被视为**动态绑定/运行时绑定**，无法实现静态绑定的常量的功能，编译和运行时也可能会消耗更多资源。两个方法各有长短，总而言之，这是一个权衡利弊的问题。

