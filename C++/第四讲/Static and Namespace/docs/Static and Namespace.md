# 第4讲:   Static and Namespace

## 4.1  Static

### 4.1.1  基本概念

#### Lifetime & Storage Duration（生命周期与存储持续时间）

生命周期是程序运行时的属性，是程序执行期间变量或函数存在的时间段。标识符（通俗地讲，就是给变量、函数、类等取的“名字”）的存储时间决定了它的生命周期

存储持续时间：

- Automatic Duration —— 具有该存储持续时间的标识符仅在其所在函数（块）执行时被分配内存，执行结束后便销毁其内存
- Static Duration —— 具有该存储持续时间的标识符在程序运行中始终占有内存，即被调用结束后所占内存不会销毁
- Dynamic Duration —— 具有该存储持续时间的标识符由程序员请求创建（new、malloc、realloc）和销毁（delete）

生命周期：

- global(static) lifetime —— 程序运行中始终存在，包括所有函数，全局变量，静态局部变量
- local(automatic) lifetime —— 只有函数执行时才存在，非静态局部变量，函数参数

#### Scope & Visibility（作用域与可见度）

一个标识符的可见度决定了它在程序的哪些部分可以被引用。进一步定义，一个标识符的作用域就是这段程序中哪些部分可以使用这个标识符，作用域大致分为四类：

File Scope —— 具有该作用域的标识符必须声明在代码块和参数列表之外。在编译单元（简单的说，就是一个.c或.cpp文件）中，该标识符可被在其声明或定义点之后的任何位置访问，这样的标识符通常被称为全局的(global)或外部的(external)，作用域为其声明位置到编译文件的末尾

Block Scope —— 具有该作用域的标识符出现在块内或函数的形参声明列表中。这样的标识符通常被称为局部的(local)，作用域为其声明或定义点到**包含其声明或定义的块**（也包括嵌套在该块中的任何块）的末尾

Function Scope 和 Function-prototype（函数原型） Scope —— 对本讲无太大关联，略去不讲，可自行查阅有关资料了解

#### Linkage（链接）

在一个大型程序中可能包含着多个文件（多个编译单元），每个编译单元可能使用了相同的标识符，链接决定了该标识符的所有声明是否针对同一对象

内部链接：仅本编译单元可见，其他编译单元不可访问。两个具有相同名字的标识符若至少一个是内部链接，则两者视为相互独立（不会引起命名冲突）

**拥有内部链接的实体**：静态全局变量，静态函数，友元函数定义，类的定义，内联函数定义等

外部链接：其他编译单元可以访问。但需要注意，拥有外部链接的标识符如果被声明在头文件并且被多个编译单元包含,可能就会出现链接冲突错误（每个包含这个标识符的编译单元都会分配空间，当编译单元链接的时候，连接器就会面对多个相同的名字，无法正常链接到正确的对象而报错）

**拥有外部链接的实体**：非静态全局变量，非静态函数，类的静态成员变量定义，类的非内联函数定义等（类内给出函数体的成员函数默认为内联函数，类外给出函数体的成员函数不是内联函数）

#### 数据的存储类型

所有的数据都有两种类型，一是常见的数据类型，如int、float等；二是数据的存储类型，共有四种存储类型，分别为自动类型（auto）、静态类型（static）、外部类型（extern）以及寄存器类型（register）

- 自动类型：函数中的非静态局部变量，local(automatic) lifetime
- 静态类型：函数中的全局变量，静态局部变量，global(static) lifetime
- 外部类型：用于拓展作用域，global(static) lifetime
- 寄存器类型：存储在cpu的寄存器中，运行速度快，local(automatic) lifetime

### 4.1.2  类外作用

#### 改变局部变量的生命周期

在函数中，对某变量添加static修饰符，使得该变量获得静态生命周期（从Automatic Duration到Static Duration），特点有

- 若不赋初值，则自动赋初值为0（非静态局部变量必须赋初值!!!）
- 只赋一次初值
- 下一次调用的值是上一次调用结束时的值

**static只改变了变量的lifetime，不改变scope!!!**

请运行**zoo.cpp**，观察有关结果

#### 使全局变量获得内部链接属性

全局变量本身具有静态生命周期，若不赋初值，则自动赋初值为0；在C或C++中，全局变量只能声明、初始化，而不能在函数外赋值

```c++
# include...
int a;              // 全局变量的声明，自动赋初值为0
int b = 8;        // 全局变量的初始化
int c;
c = 10;           // 编译不通过，不可在函数外对全局变量赋值（具体原因可自行查阅资料）
....
```

全局变量原本为外部链接属性，可以在多个编译单元中使用，添加static修饰符后，变为内部链接属性，其他编译单元不可见

请同时将**1.cpp**与**2.cpp**放在一起运行，再继续按提示逐步观察运行结果

### 4.1.3  类内作用

#### 静态成员变量

在定义一个类后并实例化一个类对象时，每个对象都会得到该类所有（非静态）成员变量的“副本”（人手一个，相互独立）。但使用了 static 关键字可以使类的成员变量成为静态的成员变量。静态成员变量的特点如下：

- 静态成员变量属于整个类所有，它的生命期不依赖于任何对象
- 静态成员变量由类的所有对象共享，同一个类的不同对象访问的静态成员是同一个
- 可以通过类名直接访问公有静态成员变量，也可以通过对象名访问公有静态成员变量

#### 静态成员函数

当静态成员变量为私有时，若想访问则必须通过函数来实现。此时，如果使用普通成员函数，则需要先实例化一个对象才可以使用该函数，针对此种情况，产生了静态成员函数。静态成员函数的特点如下：

- 静态成员函数属于整个类所有，没有this指针
- 静态成员函数只能直接访问静态成员变量和静态成员函数
- 可以通过类名直接访问类的公有静态成员函数，也可以通过对象名访问类的公有静态成员函数

**引入静态成员变量（函数）便于使同一个类产生的不同对象之间产生联系**

请运行**mem_fun.cpp**，观察运行结果



## 4.2  Namespace

### 4.2.1  命名冲突(Naming collisions) 与 命名空间简介

#### 命名冲突与解决

正如前面提到过的，一个程序中可能包含多个编译单元，不同编译单元之间可能出现了相同的标识符。在编译时，这不会出现问题，而在链接时，如果链接器无法找到一个方式将两个重名的标识符区分开以引入程序，那么就会产生错误，也就是命名冲突。在大型软件开发过程中，这种事更是无法避免。为此C++提出了Namespace（命名空间）概念。

命名空间为在其中声明的名称提供了一个作用域区域（称为**命名空间作用域** ）——在命名空间内声明的任何名称都不会被误认为是其他作用域中的相同名称，在一个命名空间内，所有名称都必须是唯一的（否则会导致命名冲突）。 

#### 全局命名空间 

在C++中，任何未在**类、函数或特定命名空间**中定义的名称都被视为隐式定义的命名空间的一部分，这被称为全局命名空间

只有声明和定义语句可以出现在全局命名空间中，其他类型的语句（例如表达式语句）不能放在全局命名空间中（全局变量的初始化例外）

```c++
# include...
// 全局命名空间
int a;              // 全局变量的声明，自动赋初值为0
int b = 8;        // 全局变量的初始化
int c;
c = 10;           // 表达式，编译不通过
....
```

#### 标准命名空间（std）

为了避免命名冲突，考虑版本兼容性，C++ 将标准库中的所有功能都移到了名为“std”（标准的缩写）的命名空间中，我们一般使用的cout，准确说法应该是”标准命名空间中的cout

### 4.2.2 命名空间

#### 命名空间的定义

命名空间的基本格式

```c++
namespace identifier
{
    entities;
}
```

举个例子

```cpp
namespace example
{
    int a = 5;
    double b = 3.1415926;
    void show() {} // do something ...
    class Point {}  // var and fun
}
```

#### 嵌套命名空间

命名空间支持嵌套

请运行**namespace1.cpp**，观察运行结果

#### 命名空间别名

如果出现了多层嵌套，或者命名空间的名字过长，可以使用别名

请运行**aliases.cpp**，观察运行结果

#### 匿名命名空间

在C++的标准中，建议使用匿名命名空间间定义编译单元内部的全局变量，替代static

匿名命名空间的定义

```c++
namespace {
    int a;
    double b;
}
```

这等价于

```c++
namespace unknown {
    int a;
    double b;
}
using namespace unknown;
```

生成的命名空间名未知（程序员也不知道），虽然命名空间具有外部链接属性，但是因为不知道该命名空间的具体名称，所以其他编译单元无法访问该命名空间中的变量，形成了全局变量仅用于该编译单元的情况

#### 多文件中的命名空间

在多个位置（跨多个文件或同一文件中的多个位置）声明命名空间块是合法的，命名空间内的所有声明都被视为命名空间的整体。

同一命名空间可在多个文件中使用

请一起运行**add.h**、**subtract.h**（声明），**math.cpp**（函数具体实现）和**main.cpp**，观察运行结果

### 4.2.3 命名空间中标识符的调用

调用命名空间中的标识符，方法有三种：

#### 使用作用域运算符(::)

只允许单次访问

如果使用了命名空间内的标识符并且没有提供范围解析，编译器将首先尝试在同一命名空间中找到匹配的声明。如果没有找到匹配的标识符，编译器将依次检查外层的命名空间（即包含该命名空间的命名空间）以查看是否找到匹配项，最后检查全局命名空间。 

#### Using declaration（声明）

在后面使用中即可直接访问该成员

申明局部变量与namespace中的原有成员相同时会报错，因为发生了冲突

调用函数与namespace中的原有成员相同时不会报错，仍调用namespace中的函数

#### Using directive（指令）

可以访问整个namespace

申明局部变量与namespace中的原有成员相同时不会报错，新的声明会掩蔽namespace中的成员

调用函数与namespace中的原有成员相同时会报错，无法区分

请运行**namespace2.cpp**，观察运行结果



## 编者注

本部分教程介绍了static修饰符和namespace，编者只是将最浅显的部分进行了介绍，对于很多概念细节，仍需大家自行查阅相关资料加以了解。

tutorial中的相关文件均在codes文件夹中，读者可自行运行查看结果，鼓励大家在此基础上再进行研究（包括修改代码运行来加深理解）

由于编者水平有限，本份教程难免有疏漏之处，还望读者批评指出。

